---
title: Smart and gets things done had better be enough
published: false
layout: post
tags: swdev
---

### "Smart and gets things done" had better be enough

When it comes to hiring software developers companies often want people with extensive experience in the toolset they'll be using on the job. By toolset I mean anything from programming language, libraries and frameworks. With the recent startup explosion we're starting to see more companies say the just want someone who's "smart and gets things done".

This is a generally positive trend that acknowledges both that the most important skill in our industry is knowing how to learn and that you're often missing the best people when you filter so narrowly.


There's another reason why smart-and-gets-things-done had better be a good enough substitute for specific experience: choice.

We've got a lot more options today when it comes to building software, particularly software that lives on the Internet.

Want to build a website? What in-browser language do you use? Javascript? Coffescript? TypeScript? ClojureScript?

Which back-end language? C#? Java? Scala? Clojure? Ruby? Javascript? Python? Erlang? Haskell?

Not only are all of these viable options, but people are using ALL of them. And each one comes with a commiserate number of libraries and frameworks for building those sites. In the experience-as-a-prerequisite world this means we'd continually be pushed into narrower and narrower job choices. You simply can't have extensive experience with all of these without redefining what extensive means.

Now like most things, the situation isn't black and white. There's a spectrum of effectiveness any given individual will have when working with a system. No one would argue that smart-and-gets-things-done with specific experience is worse than without specific experience. The question is, is there a qualitative difference between the two for reasonably high values of smart-and-gets-things-done.

### Our world isn't clean

[Some people would argue that smart and gets things done isn't enough.](foo) Reasoning from first principles doesn't work, our world isn't clean, languages and systems aren't intuitive, they're messy. These are true statements but the problem isn't fundamental. We caused this ourselves and we have a responsibility to fix it.

Being able to reason about a system is key and hasn't gone unnoticed in [recent](hickey simple) [trends](haskell or just FP popularity)

While some people might successfully argue that software development hasn't changed in a qualitative sense we're certainly writing a lot more software. There are more software companies than ever building commercial libraries and tools. Open source development has exploded and it's simply not possible to keep up anymore. You think Android has fragmentation problems? Look at any of the following slices: web development, systems integration, mobile, &lt;insert your categorization here&gt;.

### The future

If we can't build systems today that can more readily be reasoned about than the [systems](as/400 rpg) [of](CICS) [yore](other) then the problem we see in those legacy systems today only gets worse for the generation to follow us.

If we can't make systems simple enough such that smart-and-gets-things-done is enough then we're left with two possible futures:

1) The Enterprise governance route is the viable choice. When you join an organization they'll have a prescribed list of tools and libraries you can use for software development and that's all you'll ever use there. Ideally this list begins to get in sync across organizations. Productivity slows a commierstate (read: a LARGE) amount as we spend all our time reshaping those square pegs to fit into round holes. At least now those round holes are well understood and we increase the likeliness that the business can hire someone to replace us after we leave this (now miserable) career.

2) The whole system falls in on itself. The number of libraries continues to grow and our systems don't get any simpler. Systems are rewritten more and more frequently because we've now got more of them and a higher variety of components that compose them. It becomes impossible to hire people to maintain existing systems. Think it's hard to hire developers with RPG, AS/400, CICS or COBOL experience now? Wait until we're subdivided into MongoDB, Redis, Postgresql, Node.js, Scala, Clojure, Haskell, Erlang, Riak, Akka, CouchDB, RabbitMQ, ZeroMQ, Zookeeper, etc groups.

((what other components does RPG interact with?)

### Restate

More languages and more libraries exacerbate the problem of having experience. We, as a profession will either highly specialize around these languages and libraries or we'll build systems simple enough that we can still move fluidly in our industry. The former has pretty nasty consequences so let's shoot for the latter.

I'm not saying we *will* make this work, I'm saying we *have to* make it work. Our profession depends on it.

